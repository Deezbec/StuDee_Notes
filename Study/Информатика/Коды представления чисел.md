 прямой дополнительный, обратный, модифицированные коды, коды со смещением, арифметические операции, связь кодов с тиапми данных

+ Позиционная традиционная система счисления
	+ коды со смещением (множество элемент)
			+ симметричный
			+ несимметричный
	+ прямой (лежит в основе)
		+ обратный
			+ модифицировнный обратный
			+ дополнительный
				+ мод.дополнительный

## Прямой код
### общая идея 

\_. \_ \_ \_     \# `$1.101_(2пр) = -101_2$`

\_. - знаковый разряд
если число > 0 => 0, else n-1 (максимальная цифра в системе) 
._ \_ \_  — разряд модуля числа

\# `$1.101_(2пр) = -101_2$` ;    \# `$0.101_2 = 101_(2пр)$` ; 
\# `$5.302_(6пр) = -302_6$` ;    \# `$0.302_6 = 302_(6пр)$` ; 

Диапазон представления на примере четырех разрядных двоичных чисел
0-7 000
### Свойства
1) два нуля - положительный и отрицательный
2) отдельная аппаратура для + и -
3) модули и знаки обрабатываются отдельно
---

1) `$-5_10 + 3_10$`
2) `$1.101_(2пр) + 0.011_(2пр)$`
берем столько разрядов, сколько у максимального числа
3) A>B (101 > 011)
4) A - B = 010 (с помощью вычитателя) потом прибавляем знак 1010

+ Вычитатель более чем на 60 процентов сложнее сумматора
+ Для отказа от вычитателя использовать обратные или дополнительные коды

## Дополнительный код
Дополнительный код это метод вычислительной математикаи позволяющий заменить вычитание на сложение
### общая идея подхода

`$3_8 - 2_8 =  1_8$`
0   1   2   3   4   5   6   7
-    (<-|<-)
Против часовой вычитание -2(21)
0   1   2   3   4   5   6   7
|->)          (->|->|->|->|->
По часовой сложение +6 секторов (456701) 

### Свойства
1) положительные числа в дополнительном выглядят также как и в прямом
2) дополнительный код n-разрядного отрицательного числа является дополнением модуля этого чила до нуля
3) Знак числа: 0 - число положительное; максимальная цифра - число отрицательное

Дополнительный код н-разраядного отрицательного числа является дополнением модуля этого числа до нуля

---

`$-2_8 = 7.6_(8доп)$`

   0   -1   -2   -3   -4   -5   -6   -7
->)            (->|   ->| -> | ->| -> |->

количество стрелок - число после запятой
число до запятой - знак, действует по таким же законам как и знак в прямом

---

`$-7_8 = 7.1_(8доп)$`

   0   -1   -2   -3   -4   -5   -6   -7
->)                                           (->

---
У положительных чисел прямой код == дополнительный
`$11_10 = 1011_2 = 0.1011_(2пр) = 0.1011_(2доп)$`

---
Для отрицательных чисел - разряды записи модуля числа инвертируются и к младшему разряду прибавляется 1 . в Знаковом разряде записывается 1

`$-123_4 -> 3.123_(4пр) -> x_(4доп)$` 

1) `$abs(3,123_4) = 123$`

2) `$333_4$` -  максимум в 4ичной
`$333 - 123 = 210$`
Это процесс инвентирования
3) `$210 + 1 = 211$` 
+1 чтобы дайте до нуля, как в примере выше

`$-123_4 = 3.123_(4пр) = 3.211_(4доп)$`

`$-2_10 = -010_2 = 1.010_(2пр.к.) = 1.101 + 1 = 1.110_(2доп.к.)$`

почему стало 3 разряда - сам не знаю

---

Алтернатиыный способо перевода:
`$6_10 = 0110_2$`
`$-6_10=1.1010_(2доп)$`
первые два разряда меняются
 \#самНеПон

действия по переводу отрицательного числа из дополнительного кода в прямой точно такие же, как и при переводе из прямого кода в дполнительный
1.1010_(2доп.у.) = 1.0101+1
Дополнительный код
0-8 -7-6-5-4-3-2-1
1) есть только  +0
2) Мин. число требует меньше разрядов, чем аналогичное в прямом коде (-8) 1.000
`$1.000_(2доп) = 111 + 1 = 1.1000_(2пр)$`
`$1.1000_(2пр) = 0111+1 = 1.1000_(2доп)$`

## Правила сложения
1) Выровнять разрядности слагаемых
1.1пр + 0.101_2пр = 1.001_2пр + 0.101_2пр
2) перевкести слагаемый в дополнительный код
3) произвести сложение
4) единицы переноса из знакового разряда отбросить
(есть фото в телефоне)

останавились на 80