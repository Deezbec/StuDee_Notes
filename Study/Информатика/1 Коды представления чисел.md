 прямой дополнительный, обратный, модифицированные коды, коды со смещением, арифметические операции, связь кодов с тиапми данных

+ Позиционная традиционная система счисления
	+ коды со смещением (множество элемент)
			+ симметричный
			+ несимметричный
	+ прямой (лежит в основе)
		+ обратный
			+ модифицировнный обратный
			+ дополнительный
				+ мод.дополнительный

## Прямой код
### общая идея 

\_. \_ \_ \_     \# `$1.101_(2пр) = -101_2$`

\_. - знаковый разряд
если число > 0 => 0, else n-1 (максимальная цифра в системе) 
._ \_ \_  — разряд модуля числа

\# `$1.101_(2пр) = -101_2$` ;    \# `$0.101_2 = 101_(2пр)$` ; 
\# `$5.302_(6пр) = -302_6$` ;    \# `$0.302_6 = 302_(6пр)$` ; 

Диапазон представления на примере четырех разрядных двоичных чисел
0-7 000
### Свойства
1) два нуля - положительный и отрицательный
2) отдельная аппаратура для + и -
3) модули и знаки обрабатываются отдельно
---

1) `$-5_10 + 3_10$`
2) `$1.101_(2пр) + 0.011_(2пр)$`
берем столько разрядов, сколько у максимального числа
3) A>B (101 > 011)
4) A - B = 010 (с помощью вычитателя) потом прибавляем знак 1010

+ Вычитатель более чем на 60 процентов сложнее сумматора
+ Для отказа от вычитателя использовать обратные или дополнительные коды

## Дополнительный код
Дополнительный код это метод вычислительной математикаи позволяющий заменить вычитание на сложение ^be0b31
### общая идея подхода

`$3_8 - 2_8 =  1_8$`
0   1   2   3   4   5   6   7
-    (<-|<-)
Против часовой вычитание -2(21)
0   1   2   3   4   5   6   7
|->)          (->|->|->|->|->
По часовой сложение +6 секторов (456701) 

### Свойства
1) положительные числа в дополнительном выглядят также как и в прямом
2) дополнительный код n-разрядного отрицательного числа является дополнением модуля этого чила до нуля
3) Знак числа: 0 - число положительное; максимальная цифра - число отрицательное

Дополнительный код н-разраядного отрицательного числа является дополнением модуля этого числа до нуля

---

`$-2_8 = 7.6_(8доп)$`

   0   -1   -2   -3   -4   -5   -6   -7
->)            (->|   ->| -> | ->| -> |->

количество стрелок - число после запятой
число до запятой - знак, действует по таким же законам как и знак в прямом

---

`$-7_8 = 7.1_(8доп)$`

   0   -1   -2   -3   -4   -5   -6   -7
->)                                           (->

---
У положительных чисел прямой код == дополнительный
`$11_10 = 1011_2 = 0.1011_(2пр) = 0.1011_(2доп)$`

---
Для отрицательных чисел - разряды записи модуля числа инвертируются и к младшему разряду прибавляется 1 . в Знаковом разряде записывается 1

`$-123_4 -> 3.123_(4пр) -> x_(4доп)$` 

1) `$abs(3,123_4) = 123$`

2) `$333_4$` -  максимум в 4ичной
`$333 - 123 = 210$`
Это процесс инвентирования
3) `$210 + 1 = 211$` 
+1 чтобы дайте до нуля, как в примере выше

`$-123_4 = 3.123_(4пр) = 3.211_(4доп)$`

`$-2_10 = -010_2 = 1.010_(2пр.к.) = 1.101 + 1 = 1.110_(2доп.к.)$`

почему стало 3 разряда - сам не знаю

---

Алтернатиыный способо перевода:
`$6_10 = 0110_2$`
`$-6_10=1.1010_(2доп)$`
первые два разряда меняются
 \#самНеПон

действия по переводу отрицательного числа из дополнительного кода в прямой точно такие же, как и при переводе из прямого кода в дполнительный
1.1010_(2доп.у.) = 1.0101+1
Дополнительный код
0-8 -7-6-5-4-3-2-1
1) есть только  +0
2) Мин. число требует меньше разрядов, чем аналогичное в прямом коде (-8) 1.000
`$1.000_(2доп) = 111 + 1 = 1.1000_(2пр)$`
`$1.1000_(2пр) = 0111+1 = 1.1000_(2доп)$`

## Правила сложения
1) Выровнять разрядности слагаемых
1.1пр + 0.101_2пр = 1.001_2пр + 0.101_2пр
2) перевкести слагаемый в дополнительный код
3) произвести сложение
4) единицы переноса из знакового разряда отбросить
(есть фото в телефоне)

останавились на 80

дополнительный код
проверить на наличие переполнениея
при переполниении в дополнительном коде единица слева просто отбрасывается

Пример положительного переполнениия
`$0.111_(2доп) + 0.101_(2доп) = 1.100_(2доп.к.)$`
положительное переполнение

отрицательное переполнение
`$1.011_(2доп) + 1.001_(2доп) = cancel(1)0.100_(2доп)$`

`$12_10 - 59_10 = 1100_2 - 111011_2 = 0.1100_(2пр) + 1.111011_(2пр) = 0.001100_(2пр) + 1.111011_(2пр) = 0.001100_(2доп) + 1.000101_(2доп)$`
1) переведем в двоичную систему, потом в прямой код
2) выравниваем разрядности в слагаемых
3) переводим в дополнительный код
4) сложение в дополнительном коде
`$0.001100_(2доп) + 1.000101_(2доп.к.$`
5) проверяем переполнение, если нет - можно переводить в прямой код, затем в десятичный
`$1.010001_(2доп) -> 1.101110 + 1$`


`$59_10 - 12_10$`
1) перевод в двоичныую
`$1.1100_(2пр) + 0.111011_(2пр)$`
2) выровнять разрядности слагаемых
`$1.001100_(2пр) + 0.111011_(2пр)$`
3) переводим в дополнительный код
`$1.110100_(2доп) + 0.111011_(2доп)$`
4) сложить в столбик
`$1.110100 + 0.111011 = cancel(1)0.101111_(2доп)$`
5) перевод в прямой код и в 10ичную
`$0.101111_(2доп) = 0.10111_(2пр) = 47_10$`

Сложение двух отрицательных с результатом в отрицательном переполнении
`$-15_10 - 19_10 = 1.1111_(2пр) + 1.10011_(2пр) = 1.01111_(2пр) + 1.10011_(2пр) = 1.10001_(2доп) + 1.01101_(2доп) = cancel(1)0.11110_(2доп)$`
Имеется отрицательное переползнние. Задача не может быть решена в пределах 6ти разраядов. нужно увеличить разрядность слагаемых

Увеличиваем разрядность слагаемых добавив один незначащий разряд, после чего поторяем сложение

`$1.10001_(2доп) + 1.01101_(2доп)$`
стало
`$1.110001_(2доп) + 1.101101_(2доп) = cancel(1)1.011110_(2доп)$`

## Обратный код
1) Исторический предшественние дополнительного кода
2) Использовался в арифмометрах и перых ЭВМ
3) Является промежуточным этапом при переводе в дополнительнй код
Обратный код- математический метод, позволяющий заменить - на +
1) положительный числа в обратном выглядят также как и в прямом
2) Обратный код н разрядного отрицательного чилсла является дополнением модуля этого числа до максимального числа, которое можно записать при помощи н разрядов
3) знак числа - 0 - число положительное, максимальная цифра - число отрицательное

круг 0 -7 фото на телефоне
-2_8 = 7.5
5 - количество шагов до 7 на круге

действия по переводу отрицательного числа из обратного кода в прямой точно такие же, как и при переводе из прямого кода в обратный

дополнение до максимального числа в системе по модулю

11_10 = 1011_2 = 0.1011_(2пр) = 0.1011_(2обр)
-11)10 = -1011_2 = 1.1011_(2пр) = 1.0100
в обратном коде есть +0 (0.000) и -0 (1.111)

### Правило сложения для обратного кода

1) выровнять разрядности слагаемых
1.1_2пр + 0.101_2пр = 1.--1_2пр + 0.101_2пр
2) перевести слагаемые в обратный код
1.001_(2пр) = 1.110_(2обр) ; 0.101_(2пр) = 0.101_(2обр)
3) произвести сложение (знаковые разряды участвуют в сложении)
4) Единицу переноса из знакового разряда прибваить к младшему разряду суммы (ненужную единицу справа)
5) проверить наличие переполнения и отреагировать на него

`$14_10 - 8_10 = 1110_2 - 1000_2 = 0.1110_(2пр)+ 1.1000_(2пр) = 0.1110_(2обр) + 1.0111_(2обр) = 10.0101 = 0.0101 + 1 = 0.0110_(2обр) = 0.0110_(2пр) = 6_10$`

`$4_10 - 8_10 = 0.100_(2пр) + 1..1000_(2пр) = 0.0100_(2пр) + 1.1000_(2пр) = 0.0100_(2обр) + 1.0111_(2обр) = 1.1011_(2обр) = 1.0100_(2пр) = -4_10$`

случай с отрицательным переполнением
помнить про проверку разрядностей
`$-14_10 - 8_10 = -1110_2 -1000_2 = 1.1110_(2пр) + 1.1000_(2пр) = 1.0001_(2обр) + 1.0111_(2обр) = 10.1000_2(2обр) = 0.1000_(2обр) + 1 = 0.1001_(2обр) = $`

пример у меня неверен - пересчитать или у кого-то взять
не забыть про то что знаковые элементы участвуют в сложении

## Модифицированные коды
1.1011_(2доп) - отрицательное или положительное с переполнением

модифицированные коды делают двоичную запись числа однозначной
в модифицировнных кодах используются два знаковых разряда

|Код|Значение|
|-|-|
|00|положит|
|11|отрицат|
|01|положит с переполн|
|10|отриц с переполн|

правила вычислений в модифицировнных кодах такие же

-10_10 = -1010_2 = 11.0110_(2м.доп)
-9 = -1001_2 = 11.0111_(2м.доп)

`$11.0110 + 11.0111 = cancel(1)10.1101$`
отрицательное переполнение

## Коды со смещением
Сдвигают числовую шкалу в область положительных чисел
Полезно если хотим иметь только неотрицательные значения

+ ### Неcимметричный
-5,...-1,0,1..4
N = M + 1

\# Числа от -4 до 3, смещение +4
-4 = 0
-3 = 1
-2 = 2
-1 = 3
0 = 4
1 = 5 2 = 6 3 = 7

Для несимметричгог кода на базе 2 системы, если н - доступное количество разрядов, то
`$2^(n-1)$` - 1 максимальное число (1..11)
`$-2^(n-1)$` - минимальное число (0..00)
`$2^(n-1)$` - величина смещения

+ ### Симметричный

-3 до 3, смещение + 3
-3 = 0; -2 = 1; -1 = 2; 0 = 3; 1 = 4; 2 = 5; 3 = 6

`$2^(n-1) - 1$` максимальное число (1..10) - последнее обязательно 0
`$-2^(n-1)$` - минимальное число (0..00)
`$2^(n-1) - 1$` - величина смещения

Двоичная комбинация все (11..1) не используется или выполняет специальные функции


### Достоинства кода со смещением
+ облегченное сравнение чисел
сравнивать модули +Асм +Всм в других надо проверить знаки
### Недостатки кода со смещением
+ усложнение арифметики
2 раза смещение при сложении, значит по итогу надо вычесть одно смещение (фото в телефоне, там случаи разных действий)

Коды со смещением используются в стандарте IEEE754

Пример вычисления в симметричном коде
2 + (-3) в (-3 до 3) фото
101 + 000 = 101 - 011 = 010 (вычли одно смещение)
010 = 1 в коде со смещением

## Коды представления чисел и представления данных на примере с++
Дополнительный код используется в signed char, signed int, short int, long int
прямой код и симметричный код со смещением используются для float, double
*Сделать таблицу для этого*

Для выполнения вычислений в АЛУ (арифметически-логическом устройстве) - используются модифицировнный дополнительный код, прямой код и симметричный код со смещением.

```cpp
int main()
```
FF FF FF F1_16 = 1.111 1111 1111 1111 1111 1111 1111 0001_2доп = 1 000 0000 0000 0000 0000 0000 0000 1111_пр код = -15